/*
 * Copyright 2008-2017 Wells Burke
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.forty11.log;

import java.net.InetAddress;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.ThrowableInformation;

import io.forty11.j.J;

/**
/**
 * Asynchronous database appender.
 * 
 * Example Log4J config:
 *  <appender name="JDBC" class="com.liftrmt.util.JdbcAppender">
 *      <param name="Threshold" value="WARN"/>
 *      <param name="jdbcDriver" value="com.mysql.jdbc.Driver" />
 *      <param name="jdbcUrl" value="jdbc:mysql://localhost:3306/logs"/>
 *      <param name="jdbcUser" value="root" /> 
 *      <param name="jdbcPass" value="password" />
 *      <param name="table" value="Error" /> 
 *  </appender>
 * 
 * CREATE TABLE `Error` (
 *   `dayId` int(11) DEFAULT NULL,
 *   `dayKey` mediumint(3) NOT NULL DEFAULT '0',
 *   `machine` varchar(45) DEFAULT NULL,
 *   `errorCount` mediumint(3) NOT NULL DEFAULT '1',
 *   `firstError` timestamp NULL DEFAULT NULL,
 *   `lastError` timestamp NULL DEFAULT NULL,
 *   `level` varchar(45) DEFAULT NULL,
 *   `logger` varchar(255) DEFAULT NULL,
 *   `message` varchar(255) NOT NULL DEFAULT '',
 *   `error` text,
 *   `timestamp` timestamp NULL DEFAULT NULL,
 *   PRIMARY KEY (`dayKey`,`message`)
 * ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
 * 
 * 
 * @author Wells Burke
 */

public class RollingJdbcAppender extends org.apache.log4j.AppenderSkeleton implements org.apache.log4j.Appender
{
   Log                      log              = LogFactory.getLog(getClass().getName());
   String                   thisLogger       = getClass().getName();

   // -- bean properties are configurable through
   // -- the log4j logging configuration file
   String                   jdbcUrl          = null;
   String                   jdbcUser         = null;
   String                   jdbcPass         = null;

   int                      maxQueue         = 10000;
   int                      maxBatch         = 10000;

   /**
    * The db table the log statements will be written to
    */
   String                   table            = "Error";

   /**
    * Used to identify which machine the log info came from since
    * multiple machines can log to the same DB.
    * 
    * Defaults to InetAddress.getLocalHost().getHostName();
    */
   String                   machineName      = null;

   LinkedList<LoggingEvent> queue            = null;
   Connection               connection       = null;

   Thread                   writerThread     = null;
   String                   writerThreadName = getClass().getSimpleName() + ".writerThread";

   //internal state flags
   boolean                  inited           = false;
   boolean                  closed           = false;

   protected synchronized void init()
   {
      if (!inited)
      {
         queue = new LinkedList();

         writerThread = new Thread(new Runnable()
            {
               @Override
               public void run()
               {
                  insertEvents();
               }
            }, writerThreadName);
         writerThread.setDaemon(true);
         writerThread.start();

         inited = true;
      }
   }

   @Override
   public boolean requiresLayout()
   {
      return false;
   }

   @Override
   protected void append(LoggingEvent event)
   {
      if (!inited)
      {
         init();
      }

      //don't send log message created by the database logging thread
      //to the database, this will more then likely cause an infinate loop
      if (event.getThreadName().equals(writerThreadName))
         return;

      //don't send log messages generated by this appender to the DB
      if (thisLogger.equals(event.getLoggerName()))
         return;

      push(event);

   }

   @Override
   public synchronized void close()
   {
      closed = true;

      try
      {
         if (writerThread.isAlive())
         {
            writerThread.interrupt();
         }
      }
      catch (Exception ex)
      {

      }

      if (connection != null)
      {
         try
         {
            connection.close();
         }
         catch (Exception ex)
         {

         }
      }
   }

   public synchronized Connection getConnection() throws Exception
   {
      if (closed)
         return null;

      if (connection != null)
         return connection;

      try
      {
         connection = DriverManager.getConnection(jdbcUrl, jdbcUser, jdbcPass);
      }
      catch (Exception ex)
      {
         J.sleep(60000);

         // This log statement was causing a deadlock.. i think because of the synchronized
         //log.warn("Unable to get db connection to \"" + jdbcUrl + "\"", ex);
         //throw new Exception("Unable to get db connection to \"" + jdbcUrl + "\"", ex);

      }
      return connection;
   }

   protected void insertEvents()
   {
      Connection connection = null;

      while (true)
      {
         try
         {
            connection = getConnection();

            List<LoggingEvent> events = pop();

            String sql = " ";
            sql += " INSERT INTO " + table + " (dayId, dayKey, machine, errorCount, firstError, lastError, level, logger, message, error) ";
            sql += " VALUES (?,?,?,?,?,?,?,?,?,?)";
            sql += " ON DUPLICATE KEY UPDATE dayId=values(dayId),machine=values(machine),errorCount=errorCount+1,lastError=values(lastError),";
            sql += " level=values(level),logger=values(logger),message=values(message),error=values(error)";

            PreparedStatement pstmt = connection.prepareStatement(sql);

            while (events != null && events.size() > 0)
            {
               int batch = 0;
               for (LoggingEvent event : events)
               {
                  batch += 1;

                  String message = event.getMessage() + "";
                  if (message.length() > 255)
                     message = message.substring(0, 255);

                  int i = 1;

                  pstmt.setInt(i++, Integer.parseInt(new SimpleDateFormat("yyyyMMdd").format(new Date())));

                  Calendar cal = Calendar.getInstance();
                  int dayKey = cal.get(Calendar.DAY_OF_WEEK);
                  pstmt.setInt(i++, dayKey);

                  pstmt.setString(i++, getMachineName());
                  pstmt.setInt(i++, 1);
                  pstmt.setTimestamp(i++, new Timestamp(event.timeStamp));
                  pstmt.setTimestamp(i++, new Timestamp(event.timeStamp));
                  pstmt.setString(i++, event.getLevel().toString());
                  pstmt.setString(i++, event.getLoggerName());
                  pstmt.setString(i++, message);

                  ThrowableInformation ti = event.getThrowableInformation();
                  if (ti != null)
                  {
                     String exMsg = J.getShortCause(ti.getThrowable());
                     pstmt.setString(i++, exMsg);
                  }
                  else
                  {
                     pstmt.setString(i++, null);
                  }

                  pstmt.addBatch();

                  if (batch >= maxBatch)
                  {
                     batch = 0;
                     pstmt.executeBatch();
                  }
               }

               if (batch > 0)
                  pstmt.executeBatch();

               synchronized (this)
               {
                  //check to see if new events have arrived and process them 
                  //immediately if so
                  if (queue.size() > 0)
                  {
                     events = pop();
                  }
                  else
                  {
                     events = null;
                  }
               }
            }

            pstmt.close();
         }
         catch (Exception ex)
         {
            ex.printStackTrace(System.out);
            log.warn("Exception comitting a batch of log events to the db.  These log events will be thrown away.", ex);

            try
            {
               J.close(connection);
            }
            catch (Exception ex2)
            {
            }
         }
      }
   }

   synchronized void push(LoggingEvent event)
   {
      if (queue.size() >= maxQueue)
      {
         log.warn("Exceeding queue length.  LoggingEvent will be discarded" + event.getMessage());
         return;
      }

      queue.add(event);
      //if (queue.size() == 1)
      this.notifyAll();
   }

   synchronized List<LoggingEvent> pop()
   {
      while (queue.size() == 0)
      {
         try
         {
            this.wait();
            System.out.println("woke up");
         }
         catch (Exception ex)
         {
            System.out.println(ex.getMessage());
         }
      }

      List oldQueue = queue;
      queue = new LinkedList();
      return oldQueue;
   }

   /* 
   +------------------------------------------------------------------------------+
   | Property Accessors
   +------------------------------------------------------------------------------+
   */

   /**
    * defaults InetAddress.getLocalHost().getHostName();
    * @return
    */
   public String getMachineName()
   {
      if (machineName == null)
      {
         try
         {
            InetAddress addr = InetAddress.getLocalHost();

            try
            {
               machineName = addr.getHostName();
            }
            catch (Exception ex)
            {
               machineName = addr.getHostAddress();
            }

         }
         catch (Exception e)
         {
            machineName = "Unknown";
         }
      }
      return machineName;
   }

   public void setJdbcDriver(String jdbcDriver)
   {
      try
      {
         //registers with the DriverManager
         Class.forName(jdbcDriver);
      }
      catch (Exception ex)
      {

      }
   }

   public String getJdbcUrl()
   {
      return jdbcUrl;
   }

   public void setJdbcUrl(String jdbcUrl)
   {
      this.jdbcUrl = jdbcUrl;
   }

   public String getJdbcUser()
   {
      return jdbcUser;
   }

   public void setJdbcUser(String jdbcUser)
   {
      this.jdbcUser = jdbcUser;
   }

   public String getJdbcPass()
   {
      return jdbcPass;
   }

   public void setJdbcPass(String jdbcPass)
   {
      this.jdbcPass = jdbcPass;
   }

   public int getMaxQueue()
   {
      return maxQueue;
   }

   public void setMaxQueue(int maxQueue)
   {
      this.maxQueue = maxQueue;
   }

   public int getMaxBatch()
   {
      return maxBatch;
   }

   public void setMaxBatch(int maxBatch)
   {
      this.maxBatch = maxBatch;
   }

   public String getTable()
   {
      return table;
   }

   public void setTable(String table)
   {
      this.table = table;
   }

   public String getWriterThreadName()
   {
      return writerThreadName;
   }

   public void setWriterThreadName(String writerThreadName)
   {
      this.writerThreadName = writerThreadName;
   }

}
